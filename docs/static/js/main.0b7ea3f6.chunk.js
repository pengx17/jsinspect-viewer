(window.webpackJsonp = window.webpackJsonp || []).push([
  [0],
  {
    15: function(e, n, t) {},
    205: function(e, n, t) {
      'use strict';
      t.r(n);
      var a = t(0),
        o = t.n(a),
        r = t(4),
        s = t.n(r),
        d = (t(15), t(16), t(1)),
        i = t(5),
        c = t(8),
        l = t(2),
        p = t(6),
        m = t.n(p),
        u = t(7),
        h = function(e) {
          var n = e.instance,
            t = n.path.split('/');
          return o.a.createElement(
            'div',
            { style: { color: '#666', fontFamily: 'monospace' } },
            t.map(function(e, n) {
              return n !== t.length - 1
                ? e + '/'
                : o.a.createElement(
                    'span',
                    { style: { color: '#000', fontWeight: 'bold' } },
                    e
                  );
            }),
            ': ',
            JSON.stringify(n.lines),
            ',',
            ' ',
            n.lines[1] - n.lines[0]
          );
        },
        y = function(e) {
          var n = e.onFileContent,
            t = o.a.createRef();
          return o.a.createElement(
            'div',
            null,
            o.a.createElement('input', {
              ref: t,
              type: 'file',
              onInput: function() {
                if (
                  null !== t.current &&
                  t.current.files &&
                  0 !== t.current.files.length
                ) {
                  var e = new FileReader();
                  (e.onload = function() {
                    t.current && (t.current.value = '');
                    var a = JSON.parse(e.result);
                    console.log(a), n && n(a);
                  }),
                    e.readAsText(t.current.files[0]);
                }
              },
              accept: '.json',
            })
          );
        },
        g = function() {
          var e = Object(a.useState)(u),
            n = Object(l.a)(e, 2),
            t = n[0],
            r = n[1];
          Object(c.a)(t).sort(function(e, n) {
            return e.instances.length - n.instances.length;
          });
          var s = Object(a.useState)({}),
            p = Object(l.a)(s, 2),
            g = p[0],
            T = p[1];
          return o.a.createElement(
            'div',
            null,
            o.a.createElement(y, { onFileContent: r }),
            t.map(function(e) {
              return o.a.createElement(
                'div',
                { key: e.id },
                o.a.createElement(
                  'h4',
                  null,
                  'Instances: ',
                  e.instances.length
                ),
                o.a.createElement(
                  'ul',
                  null,
                  e.instances.map(function(e) {
                    return o.a.createElement(
                      'li',
                      {
                        key: e.path,
                        onClick: function() {
                          return (function(e) {
                            T(function(n) {
                              return Object(
                                i.a
                              )({}, n, Object(d.a)({}, e.path, !n[e.path]));
                            });
                          })(e);
                        },
                      },
                      o.a.createElement(h, { instance: e }),
                      g[e.path] && o.a.createElement(m.a, null, e.code)
                    );
                  })
                )
              );
            })
          );
        };
      Boolean(
        'localhost' === window.location.hostname ||
          '[::1]' === window.location.hostname ||
          window.location.hostname.match(
            /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
          )
      );
      s.a.render(o.a.createElement(g, null), document.getElementById('root')),
        'serviceWorker' in navigator &&
          navigator.serviceWorker.ready.then(function(e) {
            e.unregister();
          });
    },
    7: function(e) {
      e.exports = [
        {
          id: 'aa4d3e96a339971708cb4989b31d3ce1a9ae1293',
          instances: [
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/ad_unit_position_grid/ad_unit_position_grid_model.js',
              lines: [90, 231],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',\n              name: 'Rendition Incompatible - Indicators',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/buyer_grid/buyer_grid_model.js',
              lines: [93, 235],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/country_grid/country_grid_model.js',
              lines: [93, 234],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',\n              name: 'Rendition Incompatible - Indicators',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/daily_grid/daily_grid_model.js',
              lines: [99, 241],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/deal_grid/deal_grid_model.js',
              lines: [94, 236],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/dsp_grid/dsp_grid_model.js',
              lines: [93, 235],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/hourly_grid/hourly_grid_model.js',
              lines: [98, 240],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/section_grid/section_grid_model.js',
              lines: [102, 244],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/series_grid/series_grid_model.js',
              lines: [102, 244],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/site_grid/site_grid_model.js',
              lines: [102, 244],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/submodules/video_grid/video_grid_model.js',
              lines: [102, 243],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record) ? 0 : record.UnselectedBid;\n      const resolvedTotal = isUndefined(record) ? 0 : record.ResolvedBid;\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : record.UnselectedBidCompetitionFailure;\n      const profileCheck = isUndefined(record)\n        ? 0\n        : record.UnselectedBidProfileCheckFailed;\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value: record.ExclusivityBySlot\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value: record.AdjacentExclusivity\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value: record.Back2BackExclude\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value: record.ExceedMaxSlotDuration\n            },\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value: record.ExceedMaxNumAdvertisements\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value: record.IndustrySeparationExclude\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value: record.BrandSeparationExclude\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value: record.FrequencyCapFailed\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value: record.ClearcastNoApplicable\n            }\n          ];\n      const profileCheckData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'IncompatibleRenditionFileSize',\n              name: 'Rendition Incompatible - Size',\n              value: record.IncompatibleRenditionFileSize\n            },\n            {\n              key: 'IncompatibleRenditionDimension',\n              name: 'Rendition Incompatible - Dimensions',\n              value: record.IncompatibleRenditionDimension\n            },\n            {\n              key: 'EstimateRenditionDurationForLive',\n              name: 'Live - Estimate Duration',\n              value: record.EstimateRenditionDurationForLive\n            },\n            {\n              key: 'LargeRenditionDuration',\n              name: 'Exceeded Max Ad Duration',\n              value: record.LargeRenditionDuration\n            },\n            {\n              key: 'CreativeApiBanned',\n              name: 'Creative Api Banned',\n              value: record.CreativeApiBanned\n            },\n            {\n              key: 'IncompatibleRenditionQualification',\n              name: 'Rendition Incompatible - Indicators',",
            },
          ],
        },
        {
          id: '0eef87fe3061ecd227ed3b7e22e5da46834565a7',
          instances: [
            {
              path:
                './ui/app/audience_insights/submodules/operating_stats/operating_stats_component.jsx',
              lines: [18, 80],
              code:
                "  model: PropTypes.instanceOf(OperatingStatsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"3/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/operating_stats_component.jsx',
              lines: [20, 82],
              code:
                "  model: PropTypes.instanceOf(OperatingStatsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"3/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
            {
              path:
                './ui/app/market_insights/submodules/deals/deals_component.jsx',
              lines: [17, 79],
              code:
                "  model: PropTypes.instanceOf(DealsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"3/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/operating_stats_component.jsx',
              lines: [20, 82],
              code:
                "  model: PropTypes.instanceOf(OperatingStatsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"3/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
          ],
        },
        {
          id: '852802b0568837d76f3130c9d8f562fb957bc094',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/super_market_insights/super_market_insights_component.jsx',
              lines: [15, 77],
              code:
                "  model: PropTypes.instanceOf(SuperMarketInsightsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"9/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
            {
              path:
                './ui/app/unified_insights/submodules/super_unified_insights/super_unified_insights_component.jsx',
              lines: [14, 76],
              code:
                "  model: PropTypes.instanceOf(SuperUnifiedInsightsModel).isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const today = model.getContext('networkCurrentDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n  return (\n    <div>\n      <Row>\n        <Col sm=\"9/10\">\n          <DateRangeComponent\n            data-test-name=\"DateRangePicker\"\n            model={model.get('dateRangePicker')}",
            },
          ],
        },
        {
          id: '172a7aa5c23313b3fb31a6f15736e13d60b1b861',
          instances: [
            {
              path:
                './ui/app/audience_insights/submodules/operating_stats/submodules/audience_item_grid/audience_item_grid_model.js',
              lines: [54, 119],
              code:
                "const AudienceItemGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'TrackedRequest';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.AudienceItemName,",
            },
            {
              path:
                './ui/app/audience_insights/submodules/operating_stats/submodules/kv_term_grid/kv_term_grid_model.js',
              lines: [54, 119],
              code:
                "const KVTermGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'TrackedRequest';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.KVTermName,",
            },
          ],
        },
        {
          id: '102f7c2727d7544f3ea4f2a8fcfca3fcb12920fe',
          instances: [
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/ad_unit_grid/ad_unit_grid_model.js',
              lines: [53, 117],
              code:
                "const AdUnitGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'AdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.AdUnitName,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/delivery_method_grid/delivery_method_grid_model.js',
              lines: [50, 115],
              code:
                "const DeliveryMethodGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'AdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DeliveryMethod,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/operator_zone_grid/operator_zone_grid_model.js',
              lines: [53, 118],
              code:
                "const OperatorZoneGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'AdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.OperatorZoneName,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/rendition_grid/rendition_grid_model.js',
              lines: [53, 118],
              code:
                "const RenditionGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'AdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.RenditionName,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/tv_network_grid/tv_network_grid_model.js',
              lines: [53, 118],
              code:
                "const TVNetworkGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'AdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.TVNetworkName,",
            },
          ],
        },
        {
          id: 'ad0c00c268a4fef030d9aa679e352acb6b2f8862',
          instances: [
            {
              path:
                './ui/app/demand_insights/submodules/traffic/submodules/country_grid/country_grid_model.js',
              lines: [47, 118],
              code:
                "const CountryGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n    params.searchBy = '';\n    params.searchVal = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.CountryName,",
            },
            {
              path:
                './ui/app/demand_insights/submodules/traffic/submodules/deal_grid/deal_grid_model.js',
              lines: [48, 119],
              code:
                "const DealGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n    params.searchBy = '';\n    params.searchVal = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DealPublicID,",
            },
            {
              path:
                './ui/app/demand_insights/submodules/traffic/submodules/device_grid/device_grid_model.js',
              lines: [44, 115],
              code:
                "const DeviceGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n    params.searchBy = '';\n    params.searchVal = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DeviceType,",
            },
            {
              path:
                './ui/app/demand_insights/submodules/traffic/submodules/pg_deal_grid/pg_deal_grid_model.js',
              lines: [48, 119],
              code:
                "const PGDealGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n    params.searchBy = '';\n    params.searchVal = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        let { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DealPublicID,",
            },
            {
              path:
                './ui/app/demand_insights/submodules/traffic/submodules/seat_grid/seat_grid_model.js',
              lines: [47, 118],
              code:
                "const SeatGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n    params.searchBy = '';\n    params.searchVal = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        let { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.SeatID,",
            },
          ],
        },
        {
          id: 'a6e1e3bfa2880ec9d17e44c4166a5c28d1e23f1b',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/daily_grid/daily_grid_model.js',
              lines: [119, 315],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/hourly_grid/hourly_grid_model.js',
              lines: [118, 314],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/sections_grid/sections_grid_model.js',
              lines: [123, 319],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/series_grid/series_grid_model.js',
              lines: [142, 338],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/sites_grid/sites_grid_model.js',
              lines: [143, 339],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/videos_grid/videos_grid_model.js',
              lines: [122, 318],
              code:
                "    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n      const record = data && data[0];\n      const unselectedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedUnselectedTotal) +\n          (chartShowORTB && record.ORtbUnselectedTotal);\n      const resolvedTotal = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved);\n      const competitionFailure = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedCompetitionFailure) +\n          (chartShowORTB && record.ORtbCompetitionFailure);\n      const profileCheck = isUndefined(record)\n        ? 0\n        : (chartShowTagBased && record.TBasedProfileCheckFailed) +\n          (chartShowORTB && record.ORtbProfileCheckFailed);\n\n      const competitionFailureData = isUndefined(record)\n        ? []\n        : [\n            {\n              key: 'ExceededMaxNumberofAds',\n              name: 'Exceeded Max Number of Ads',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedExceedMaxNumAdvertisements) +\n                (chartShowORTB && record.ORtbExceedMaxNumAdvertisements)\n            },\n            {\n              key: 'SlotExclusivity',\n              name: 'Slot Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedExclusivityBySlot) +\n                (chartShowORTB && record.ORtbExclusivityBySlot)\n            },\n            {\n              key: 'AdjacentAdsExclusivity',\n              name: 'Adjacent Ads Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedAdjacentExclusivity) +\n                (chartShowORTB && record.ORtbAdjacentExclusivity)\n            },\n            {\n              key: 'BacktoBack',\n              name: 'Back to Back',\n              value:\n                (chartShowTagBased && record.TBasedBack2BackExclude) +\n                (chartShowORTB && record.ORtbBack2BackExclude)\n            },\n            {\n              key: 'ExceededMaxSlotDuration',\n              name: 'Exceeded Max Slot Duration',\n              value:\n                (chartShowTagBased && record.TBasedExceedMaxSlotDuration) +\n                (chartShowORTB && record.ORtbExceedMaxSlotDuration)\n            },\n            {\n              key: 'IndustryExclusivity',\n              name: 'Industry Exclusivity',\n              value:\n                (chartShowTagBased &&\n                  record.TBasedIndustrySeparationExclude) +\n                (chartShowORTB && record.ORtbIndustrySeparationExclude)\n            },\n            {\n              key: 'BrandExclusivity',\n              name: 'Brand Exclusivity',\n              value:\n                (chartShowTagBased && record.TBasedBrandSeparationExclude) +\n                (chartShowORTB && record.ORtbBrandSeparationExclude)\n            },\n            {\n              key: 'FrequencyCap',\n              name: 'Frequency Cap',\n              value:\n                (chartShowTagBased && record.TBasedFrequencyCapFailed) +\n                (chartShowORTB && record.ORtbFrequencyCapFailed)\n            },\n            {\n              key: 'ClearcastNoApplicable',\n              name: 'Clearcast Restriction',\n              value:\n                (chartShowTagBased && record.TBasedClearcastNoApplicable) +\n                (chartShowORTB && record.ORtbClearcastNoApplicable)\n            }\n          ];\n",
            },
          ],
        },
        {
          id: '5e1b0bd4acf21d85394636a8e2af3d79162ef737',
          instances: [
            {
              path: './ui/app/audience_insights/lib/grid_common.js',
              lines: [11, 105],
              code:
                "  isInternalColsVisible: PropTypes.bool,\n  ChartsModel: PropTypes.instanceOf(Model).isRequired,\n  FilterModel: PropTypes.instanceOf(CombinedFilterModel)\n};\n\nexport const marketExportQuery = (isCurrent = false, self) => {\n  let query = '';\n  const params = self.getParams();\n  const postfix = moment().format('YYYYMMDDHHmmssSSS');\n  const filename = `${params.networkId}_${self.get('tabName')}_${\n    params.startDate\n  }_${params.endDate}_${postfix}.csv`;\n  query += `&filename=${filename}`;\n\n  query += `&network_id=${params.networkId}`;\n  query += `&start_date=${params.startDate}`;\n  query += `&end_date=${params.endDate}`;\n  query += `&order_by=${params.orderBy}`;\n  query += `&order=${params.order}`;\n  query += `&queries=${params.queries}`;\n  query += `&total=all`;\n  query += `&entities=${params.entities}`;\n  let exportCols = [];\n  let exportNames = [];\n  const headerNameList = self.getContext('headerName');\n  if (isCurrent) {\n    query += `&page=${params.page}`;\n    query += `&per_page=${params.perPage}`;\n    if (params.searchBy !== '') {\n      query += `&search_by=${params.searchBy}`;\n      query += `&search_val=${params.searchVal}`;\n    }\n\n    const headers = self.get('headers');\n    const hiddenHeaders = self.get('displayOperationModel').getColumnStatus();\n\n    headers.map(header => {\n      if (!hiddenHeaders[header]) {\n        exportCols.push(header);\n        exportNames.push(headerNameList.get(header));\n      }\n    });\n  } else {\n    const headers = self.get('headers');\n    headers.map(header => {\n      exportNames.push(headerNameList.get(header));\n    });\n    exportCols = self.get('headers').toJS();\n  }\n  query += `&fields=${exportCols.join(',')}`;\n  query += `&headers=${exportNames.join(',')}`;\n\n  return query;\n};\n\nexport const marketGetParams = self => {\n  let keyWord = '';\n  let fields = new List([]);\n  self\n    .get('search')\n    .get('activeQueries')\n    .map(query => {\n      keyWord = query.get('value').toLowerCase();\n      fields = fields.push(query.get('key'));\n    });\n  const searchBy = fields.join(',');\n  const searchVal = keyWord;\n\n  const filterModel = self.getContext('FilterModel');\n  let queries = [];\n\n  if (!isUndefined(filterModel)) {\n    const filters = filterModel.get('filters');\n    filters.map(f => {\n      if (!isUndefined(f.get('value')) && f.get('value') !== null) {\n        queries.push(`${f.get('subKey')}:${f.get('value')}`);\n      }\n    });\n  }\n\n  return {\n    networkId: self.getContext('networkId'),\n    startDate: self.getContext('startDate'),\n    endDate: self.getContext('endDate'),\n    orderBy: self.get('sort').get('orderBy'),\n    order: self.get('sort').get('order'),\n    page: self.get('pagination').get('page'),\n    perPage: self.get('pagination').get('perPage'),\n    total: self.get('total'),\n    searchBy,\n    searchVal,\n    queries: queries.join(','),\n    entities: self.get('entity').join(',')\n  };\n};",
            },
            {
              path: './ui/app/linear_insights/lib/grid_common.js',
              lines: [11, 105],
              code:
                "  isInternalColsVisible: PropTypes.bool,\n  ChartsModel: PropTypes.instanceOf(Model).isRequired,\n  FilterModel: PropTypes.instanceOf(CombinedFilterModel)\n};\n\nexport const marketExportQuery = (isCurrent = false, self) => {\n  let query = '';\n  const params = self.getParams();\n  const postfix = moment().format('YYYYMMDDHHmmssSSS');\n  const filename = `${params.networkId}_${self.get('tabName')}_${\n    params.startDate\n  }_${params.endDate}_${postfix}.csv`;\n  query += `&filename=${filename}`;\n\n  query += `&network_id=${params.networkId}`;\n  query += `&start_date=${params.startDate}`;\n  query += `&end_date=${params.endDate}`;\n  query += `&order_by=${params.orderBy}`;\n  query += `&order=${params.order}`;\n  query += `&queries=${params.queries}`;\n  query += `&total=all`;\n  query += `&entities=${params.entities}`;\n  let exportCols = [];\n  let exportNames = [];\n  const headerNameList = self.getContext('headerName');\n  if (isCurrent) {\n    query += `&page=${params.page}`;\n    query += `&per_page=${params.perPage}`;\n    if (params.searchBy !== '') {\n      query += `&search_by=${params.searchBy}`;\n      query += `&search_val=${params.searchVal}`;\n    }\n\n    const headers = self.get('headers');\n    const hiddenHeaders = self.get('displayOperationModel').getColumnStatus();\n\n    headers.map(header => {\n      if (!hiddenHeaders[header]) {\n        exportCols.push(header);\n        exportNames.push(headerNameList.get(header));\n      }\n    });\n  } else {\n    const headers = self.get('headers');\n    headers.map(header => {\n      exportNames.push(headerNameList.get(header));\n    });\n    exportCols = self.get('headers').toJS();\n  }\n  query += `&fields=${exportCols.join(',')}`;\n  query += `&headers=${exportNames.join(',')}`;\n\n  return query;\n};\n\nexport const marketGetParams = self => {\n  let keyWord = '';\n  let fields = new List([]);\n  self\n    .get('search')\n    .get('activeQueries')\n    .map(query => {\n      keyWord = query.get('value').toLowerCase();\n      fields = fields.push(query.get('key'));\n    });\n  const searchBy = fields.join(',');\n  const searchVal = keyWord;\n\n  const filterModel = self.getContext('FilterModel');\n  let queries = [];\n\n  if (!isUndefined(filterModel)) {\n    const filters = filterModel.get('filters');\n    filters.map(f => {\n      if (!isUndefined(f.get('value')) && f.get('value') !== null) {\n        queries.push(`${f.get('subKey')}:${f.get('value')}`);\n      }\n    });\n  }\n\n  return {\n    networkId: self.getContext('networkId'),\n    startDate: self.getContext('startDate'),\n    endDate: self.getContext('endDate'),\n    orderBy: self.get('sort').get('orderBy'),\n    order: self.get('sort').get('order'),\n    page: self.get('pagination').get('page'),\n    perPage: self.get('pagination').get('perPage'),\n    total: self.get('total'),\n    searchBy,\n    searchVal,\n    queries: queries.join(','),\n    entities: self.get('entity').join(',')\n  };\n};",
            },
            {
              path: './ui/app/market_insights/lib/grid_common.js',
              lines: [13, 107],
              code:
                "  openRTBEnabled: PropTypes.bool,\n  ChartsModel: PropTypes.instanceOf(Model).isRequired,\n  FilterModel: PropTypes.instanceOf(CombinedFilterModel)\n};\n\nexport const marketExportQuery = (isCurrent = false, self) => {\n  let query = '';\n  const params = self.getParams();\n  const postfix = moment().format('YYYYMMDDHHmmssSSS');\n  const filename = `${params.networkId}_${self.get('tabName')}_${\n    params.startDate\n  }_${params.endDate}_${postfix}.csv`;\n  query += `&filename=${filename}`;\n\n  query += `&network_id=${params.networkId}`;\n  query += `&start_date=${params.startDate}`;\n  query += `&end_date=${params.endDate}`;\n  query += `&order_by=${params.orderBy}`;\n  query += `&order=${params.order}`;\n  query += `&queries=${params.queries}`;\n  query += `&total=all`;\n  query += `&entities=${params.entities}`;\n  let exportCols = [];\n  let exportNames = [];\n  const headerNameList = self.getContext('headerName');\n  if (isCurrent) {\n    query += `&page=${params.page}`;\n    query += `&per_page=${params.perPage}`;\n    if (params.searchBy !== '') {\n      query += `&search_by=${params.searchBy}`;\n      query += `&search_val=${params.searchVal}`;\n    }\n\n    const headers = self.get('headers');\n    const hiddenHeaders = self.get('displayOperationModel').getColumnStatus();\n\n    headers.map(header => {\n      if (!hiddenHeaders[header]) {\n        exportCols.push(header);\n        exportNames.push(headerNameList.get(header));\n      }\n    });\n  } else {\n    const headers = self.get('headers');\n    headers.map(header => {\n      exportNames.push(headerNameList.get(header));\n    });\n    exportCols = self.get('headers').toJS();\n  }\n  query += `&fields=${exportCols.join(',')}`;\n  query += `&headers=${exportNames.join(',')}`;\n\n  return query;\n};\n\nexport const marketGetParams = self => {\n  let keyWord = '';\n  let fields = new List([]);\n  self\n    .get('search')\n    .get('activeQueries')\n    .map(query => {\n      keyWord = query.get('value').toLowerCase();\n      fields = fields.push(query.get('key'));\n    });\n  const searchBy = fields.join(',');\n  const searchVal = keyWord;\n\n  const filterModel = self.getContext('FilterModel');\n  let queries = [];\n\n  if (!isUndefined(filterModel)) {\n    const filters = filterModel.get('filters');\n    filters.map(f => {\n      if (!isUndefined(f.get('value')) && f.get('value') !== null) {\n        queries.push(`${f.get('subKey')}:${f.get('value')}`);\n      }\n    });\n  }\n\n  return {\n    networkId: self.getContext('networkId'),\n    startDate: self.getContext('startDate'),\n    endDate: self.getContext('endDate'),\n    orderBy: self.get('sort').get('orderBy'),\n    order: self.get('sort').get('order'),\n    page: self.get('pagination').get('page'),\n    perPage: self.get('pagination').get('perPage'),\n    total: self.get('total'),\n    searchBy,\n    searchVal,\n    queries: queries.join(','),\n    entities: self.get('entity').join(',')\n  };\n};",
            },
          ],
        },
        {
          id: '5c19c6cc0527b874028353c216ffceed5d0157aa',
          instances: [
            {
              path: './ui/app/demand_insights/lib/grid_common.js',
              lines: [66, 100],
              code:
                "export const demandGetParams = self => {\n  let keyWord = '';\n  let fields = new List([]);\n  self\n    .get('search')\n    .get('activeQueries')\n    .map(query => {\n      keyWord = query.get('value').toLowerCase();\n      fields = fields.push(query.get('key'));\n    });\n  const searchBy = fields.join(',');\n  const searchVal = keyWord;\n\n  const filterModel = self.getContext('FilterModel');\n  let queries = [];\n\n  if (!isUndefined(filterModel)) {\n    const filters = filterModel.get('filters');\n    filters.map(f => {\n      if (!isUndefined(f.get('value')) && f.get('value') !== null) {\n        queries.push(`${f.get('subKey')}:${f.get('value')}`);\n      }\n    });\n  }\n\n  return {\n    networkId: self.getContext('networkId'),\n    startDate: self.getContext('startDate'),\n    endDate: self.getContext('endDate'),\n    orderBy: self.get('sort').get('orderBy'),\n    order: self.get('sort').get('order'),\n    page: self.get('pagination').get('page'),\n    perPage: self.get('pagination').get('perPage'),\n    total: self.get('total'),\n    entities: '',",
            },
            {
              path: './ui/app/unified_insights/lib/grid_common.js',
              lines: [65, 99],
              code:
                "export const unifiedGetParams = self => {\n  let keyWord = '';\n  let fields = new List([]);\n  self\n    .get('search')\n    .get('activeQueries')\n    .map(query => {\n      keyWord = query.get('value').toLowerCase();\n      fields = fields.push(query.get('key'));\n    });\n  const searchBy = fields.join(',');\n  const searchVal = keyWord;\n\n  const filterModel = self.getContext('FilterModel');\n  let queries = [];\n\n  if (!isUndefined(filterModel)) {\n    const filters = filterModel.get('filters');\n    filters.map(f => {\n      if (!isUndefined(f.get('value')) && f.get('value') !== null) {\n        queries.push(`${f.get('subKey')}:${f.get('value')}`);\n      }\n    });\n  }\n\n  return {\n    networkId: self.getContext('networkId'),\n    startDate: self.getContext('startDate'),\n    endDate: self.getContext('endDate'),\n    orderBy: self.get('sort').get('orderBy'),\n    order: self.get('sort').get('order'),\n    page: self.get('pagination').get('page'),\n    perPage: self.get('pagination').get('perPage'),\n    total: self.get('total'),\n    searchBy,",
            },
          ],
        },
        {
          id: 'f4b8edcca18a948529f197e9bb141d9025adaee4',
          instances: [
            {
              path:
                './ui/app/demand_insights/submodules/rejections/submodules/country_grid/country_grid_model.js',
              lines: [48, 134],
              code:
                "const CountryGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    RejectionChartsModel: PropTypes.instanceOf(Model).isRequired,\n    PieChartModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.entities = 'errorBid,commonImpression';\n    params.total = 'all';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n\n        const totalData = data && data[0];\n        const detailData = data && data.slice(1);\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { detailData, totalData }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { detailData, totalData } = action.payload;\n        const chartsModel = model.getContext('RejectionChartsModel');\n        const PieChartModel = model.getContext('PieChartModel');\n\n        const rejectionReasonArr = Object.keys(RejectionReason);\n\n        const barMetrics = fromJS(rejectionReasonArr);\n        const rejectionBarData = detailData.map(record => {\n          return rejectionReasonArr.reduce(\n            (res, item) => {\n              res[item] = record[item] || 0;\n              return res;\n            },\n            {\n              dataKey: record.CountryName",
            },
            {
              path:
                './ui/app/demand_insights/submodules/rejections/submodules/deal_grid/deal_grid_model.js',
              lines: [51, 136],
              code:
                "const DealGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    RejectionChartsModel: PropTypes.instanceOf(Model).isRequired,\n    PieChartModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.entities = 'errorBid,commonImpression';\n    params.total = 'all';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        const totalData = data && data[0];\n        const detailData = data && data.slice(1);\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { detailData, totalData }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { detailData, totalData } = action.payload;\n        const chartsModel = model.getContext('RejectionChartsModel');\n        const PieChartModel = model.getContext('PieChartModel');\n\n        const rejectionReasonArr = Object.keys(RejectionReason);\n\n        const barMetrics = fromJS(rejectionReasonArr);\n        const rejectionBarData = detailData.map(record => {\n          return rejectionReasonArr.reduce(\n            (res, item) => {\n              res[item] = record[item] || 0;\n              return res;\n            },\n            {\n              dataKey: record.DealPublicID",
            },
            {
              path:
                './ui/app/demand_insights/submodules/rejections/submodules/pg_deal_grid/pg_deal_grid_model.js',
              lines: [51, 136],
              code:
                "const PGDealGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    RejectionChartsModel: PropTypes.instanceOf(Model).isRequired,\n    PieChartModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.entities = 'errorBid,commonImpression';\n    params.total = 'all';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        const totalData = data && data[0];\n        const detailData = data && data.slice(1);\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { detailData, totalData }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { detailData, totalData } = action.payload;\n        const chartsModel = model.getContext('RejectionChartsModel');\n        const PieChartModel = model.getContext('PieChartModel');\n\n        const rejectionReasonArr = Object.keys(RejectionReason);\n\n        const barMetrics = fromJS(rejectionReasonArr);\n        const rejectionBarData = detailData.map(record => {\n          return rejectionReasonArr.reduce(\n            (res, item) => {\n              res[item] = record[item] || 0;\n              return res;\n            },\n            {\n              dataKey: record.DealPublicID",
            },
            {
              path:
                './ui/app/demand_insights/submodules/rejections/submodules/seat_grid/seat_grid_model.js',
              lines: [48, 133],
              code:
                "const SeatGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...demandContextTypes,\n    RejectionChartsModel: PropTypes.instanceOf(Model).isRequired,\n    PieChartModel: PropTypes.instanceOf(Model).isRequired,\n    pushUrl: PropTypes.func\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      autoLoad: true,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    if (!this.validParams(params)) {\n      return;\n    }\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.entities = 'errorBid,commonImpression';\n    params.total = 'all';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        const totalData = data && data[0];\n        const detailData = data && data.slice(1);\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { detailData, totalData }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        let { detailData, totalData } = action.payload;\n        const chartsModel = model.getContext('RejectionChartsModel');\n        const PieChartModel = model.getContext('PieChartModel');\n\n        const rejectionReasonArr = Object.keys(RejectionReason);\n\n        const barMetrics = fromJS(rejectionReasonArr);\n        const rejectionBarData = detailData.map(record => {\n          return rejectionReasonArr.reduce(\n            (res, item) => {\n              res[item] = record[item] || 0;\n              return res;\n            },\n            {\n              dataKey: record.ExternalSeatID",
            },
          ],
        },
        {
          id: '3fb5939945a2298c69c7e7df86e62afae3ac2e4f',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/sections_grid/sections_grid_model.js',
              lines: [61, 154],
              code:
                "const SectionGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    const chartShowTagBased = this.get('chartShowTagBased');\n    const chartShowORTB = this.get('chartShowORTB');\n    let orderBy = 'SumTBasedORTBPrimaryImpression';\n    if (chartShowTagBased && !chartShowORTB) {\n      orderBy = 'TBasedNonFallbackMarketAdImpression';\n    } else if (!chartShowTagBased && chartShowORTB) {\n      orderBy = 'ORtbNonFallbackMarketAdImpression';\n    }\n    let params = this.getParams();\n    params.orderBy = orderBy;\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.SectionName,",
            },
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/series_grid/series_grid_model.js',
              lines: [60, 153],
              code:
                "const SeriesGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    const chartShowTagBased = this.get('chartShowTagBased');\n    const chartShowORTB = this.get('chartShowORTB');\n    let orderBy = 'SumTBasedORTBPrimaryImpression';\n    if (chartShowTagBased && !chartShowORTB) {\n      orderBy = 'TBasedNonFallbackMarketAdImpression';\n    } else if (!chartShowTagBased && chartShowORTB) {\n      orderBy = 'ORtbNonFallbackMarketAdImpression';\n    }\n    let params = this.getParams();\n    params.orderBy = orderBy;\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.SeriesName,",
            },
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/sites_grid/sites_grid_model.js',
              lines: [61, 154],
              code:
                "const SitesGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    const chartShowTagBased = this.get('chartShowTagBased');\n    const chartShowORTB = this.get('chartShowORTB');\n    let orderBy = 'SumTBasedORTBPrimaryImpression';\n    if (chartShowTagBased && !chartShowORTB) {\n      orderBy = 'TBasedNonFallbackMarketAdImpression';\n    } else if (!chartShowTagBased && chartShowORTB) {\n      orderBy = 'ORtbNonFallbackMarketAdImpression';\n    }\n    let params = this.getParams();\n    params.orderBy = orderBy;\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.SiteName,",
            },
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/videos_grid/videos_grid_model.js',
              lines: [60, 153],
              code:
                "const VideosGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    const chartShowTagBased = this.get('chartShowTagBased');\n    const chartShowORTB = this.get('chartShowORTB');\n    let orderBy = 'SumTBasedORTBPrimaryImpression';\n    if (chartShowTagBased && !chartShowORTB) {\n      orderBy = 'TBasedNonFallbackMarketAdImpression';\n    } else if (!chartShowTagBased && chartShowORTB) {\n      orderBy = 'ORtbNonFallbackMarketAdImpression';\n    }\n    let params = this.getParams();\n    params.orderBy = orderBy;\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.VideoName,",
            },
          ],
        },
        {
          id: '474749ee12362a2e96bfe0a8469730cdb0ae1cfb',
          instances: [
            {
              path:
                './ui/app/demand_insights/submodules/rejections/rejections_component.jsx',
              lines: [23, 88],
              code:
                "  model: PropTypes.instanceOf(RejectionsModel).isRequired\n},\n\ncontextTypes: {\n  router: PropTypes.object.isRequired,\n  getAbsoluteUrl: PropTypes.func.isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const { router, getAbsoluteUrl } = this.context;\n  const today = model.getContext('networkCurrentDate');\n  const enableHourly = model.get('startDate') === model.get('endDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n\n  return (\n    <div>",
            },
            {
              path:
                './ui/app/demand_insights/submodules/traffic/traffic_component.jsx',
              lines: [22, 87],
              code:
                "  model: PropTypes.instanceOf(TrafficModel).isRequired\n},\n\ncontextTypes: {\n  router: PropTypes.object.isRequired,\n  getAbsoluteUrl: PropTypes.func.isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const { router, getAbsoluteUrl } = this.context;\n  const today = model.getContext('networkCurrentDate');\n  const enableHourly = model.get('startDate') === model.get('endDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n\n  return (\n    <div>",
            },
            {
              path:
                './ui/app/demand_insights/submodules/troubleshooting/troubleshooting_component.jsx',
              lines: [20, 85],
              code:
                "  model: PropTypes.instanceOf(TroubleshootingModel).isRequired\n},\n\ncontextTypes: {\n  router: PropTypes.object.isRequired,\n  getAbsoluteUrl: PropTypes.func.isRequired\n},\n\nrender() {\n  const model = this.props.model;\n  const { router, getAbsoluteUrl } = this.context;\n  const today = model.getContext('networkCurrentDate');\n  const enableHourly = model.get('startDate') === model.get('endDate');\n  const shortcuts = [\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-7, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 7 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-14, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 14 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-28, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 28 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-30, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 30 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-60, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 60 Days'\n    },\n    {\n      type: 'fixed',\n      start: moment(today)\n        .add(-90, 'days')\n        .format('YYYY-MM-DD'),\n      end: today,\n      name: 'Last 90 Days'\n    }\n  ];\n\n  return (\n    <div>",
            },
          ],
        },
        {
          id: 'a224fc0f610881b25b7492c5fe557e28077d99bc',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/deals/submodules/dsp_grid/dsp_grid_model.js',
              lines: [47, 154],
              code:
                "const ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst DspGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendUpdatechartDisplay() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    this.dispatch({ type: ActionTypes.UPDATE_CHARTDISPLAY });\n  },\n\n  recvUpdatechartDisplay() {\n    return {\n      type: ActionTypes.UPDATE_CHARTDISPLAY,\n      update(model) {\n        return [model, model.sendLoadChart];\n      }\n    };\n  },\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'ORtbNonFallbackMarketAdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.SFXDSPName,\n          Resolved: record.ORtbResolved,\n          PrimaryAdSelected: record.ORtbNonFallbackMarketAdSelected,\n          PrimaryAdRealSelected: record.ORtbNonFallbackMarketAdRealSelected,\n          PrimaryAdImpression: record.ORtbNonFallbackMarketAdImpression\n        }));\n        const chartsModel = model.getContext('ChartsModel');\n        const barMetrics = fromJS([\n          'Resolved',\n          'PrimaryAdRealSelected',\n          'PrimaryAdSelected',\n          'PrimaryAdImpression'\n        ]);\n        const lineMetrics = fromJS([]);\n        return [",
            },
            {
              path:
                './ui/app/market_insights/submodules/super_market_insights/submodules/dsp_grid/dsp_grid_model.js',
              lines: [47, 154],
              code:
                "const ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst DspGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendUpdatechartDisplay() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    this.dispatch({ type: ActionTypes.UPDATE_CHARTDISPLAY });\n  },\n\n  recvUpdatechartDisplay() {\n    return {\n      type: ActionTypes.UPDATE_CHARTDISPLAY,\n      update(model) {\n        return [model, model.sendLoadChart];\n      }\n    };\n  },\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'ORtbNonFallbackMarketAdImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 5;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.SFXDSPName,\n          Resolved: record.ORtbResolved,\n          PrimaryAdSelected: record.ORtbNonFallbackMarketAdSelected,\n          PrimaryAdRealSelected: record.ORtbNonFallbackMarketAdRealSelected,\n          PrimaryAdImpression: record.ORtbNonFallbackMarketAdImpression\n        }));\n        const chartsModel = model.getContext('ChartsModel');\n        const barMetrics = fromJS([\n          'Resolved',\n          'PrimaryAdRealSelected',\n          'PrimaryAdSelected',\n          'PrimaryAdImpression'\n        ]);\n        const lineMetrics = fromJS([]);\n        return [",
            },
          ],
        },
        {
          id: '4318397e4e235d8db0a6b72c44bd48e459c57df0',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/filter_reasons_component.jsx',
              lines: [221, 280],
              code:
                "      </div>\n    );\n  }\n});\n\nconst GridsComponent = ({ model }) => {\n  const enabledHourly = model.get('startDate') === model.get('endDate');\n  return (\n    <div>\n      <Tab data-test-name=\"subTab\">\n        <TabItem\n          active={model.get('activeTab') === 'daily'}\n          onClick={() => {\n            model.sendTabToggle('daily');\n          }}\n        >\n          Daily\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'hourly'}\n          onClick={() => {\n            if (enabledHourly) {\n              model.sendTabToggle('hourly');\n            }\n          }}\n        >\n          <span style={enabledHourly ? {} : { color: '#CCCCCC' }}>Hourly</span>\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'series'}\n          onClick={() => {\n            model.sendTabToggle('series');\n          }}\n        >\n          Video Series\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'video'}\n          onClick={() => {\n            model.sendTabToggle('video');\n          }}\n        >\n          Videos\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'site'}\n          onClick={() => {\n            model.sendTabToggle('site');\n          }}\n        >\n          Sites\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'section'}\n          onClick={() => {\n            model.sendTabToggle('section');\n          }}\n        >\n          Site Sections\n        </TabItem>",
            },
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/operating_stats_component.jsx',
              lines: [103, 162],
              code:
                "      </div>\n    );\n  }\n});\n\nconst GridsComponent = ({ model }) => {\n  const enabledHourly = model.get('startDate') === model.get('endDate');\n  return (\n    <div>\n      <Tab data-test-name=\"subTab\">\n        <TabItem\n          active={model.get('activeTab') === 'daily'}\n          onClick={() => {\n            model.sendTabToggle('daily');\n          }}\n        >\n          Daily\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'hourly'}\n          onClick={() => {\n            if (enabledHourly) {\n              model.sendTabToggle('hourly');\n            }\n          }}\n        >\n          <span style={enabledHourly ? {} : { color: '#CCCCCC' }}>Hourly</span>\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'series'}\n          onClick={() => {\n            model.sendTabToggle('series');\n          }}\n        >\n          Video Series\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'video'}\n          onClick={() => {\n            model.sendTabToggle('video');\n          }}\n        >\n          Videos\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'site'}\n          onClick={() => {\n            model.sendTabToggle('site');\n          }}\n        >\n          Sites\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'section'}\n          onClick={() => {\n            model.sendTabToggle('section');\n          }}\n        >\n          Site Sections\n        </TabItem>",
            },
            {
              path:
                './ui/app/unified_insights/submodules/filterReason/filter_reasons_component.jsx',
              lines: [207, 266],
              code:
                "      </div>\n    );\n  }\n});\n\nconst GridsComponent = ({ model }) => {\n  const enabledHourly = model.get('startDate') === model.get('endDate');\n  return (\n    <div>\n      <Tab data-test-name=\"subTab\">\n        <TabItem\n          active={model.get('activeTab') === 'daily'}\n          onClick={() => {\n            model.sendTabToggle('daily');\n          }}\n        >\n          Daily\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'hourly'}\n          onClick={() => {\n            if (enabledHourly) {\n              model.sendTabToggle('hourly');\n            }\n          }}\n        >\n          <span style={enabledHourly ? {} : { color: '#CCCCCC' }}>Hourly</span>\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'series'}\n          onClick={() => {\n            model.sendTabToggle('series');\n          }}\n        >\n          Video Series\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'video'}\n          onClick={() => {\n            model.sendTabToggle('video');\n          }}\n        >\n          Videos\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'site'}\n          onClick={() => {\n            model.sendTabToggle('site');\n          }}\n        >\n          Sites\n        </TabItem>\n        <TabItem\n          active={model.get('activeTab') === 'section'}\n          onClick={() => {\n            model.sendTabToggle('section');\n          }}\n        >\n          Site Sections\n        </TabItem>",
            },
          ],
        },
        {
          id: '67f4e527c8253226a6bd462fc693a63e00fe20d8',
          instances: [
            {
              path:
                './ui/app/unified_insights/submodules/demand/submodules/deal_grid/deal_grid_model.js',
              lines: [48, 116],
              code:
                "const DealGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...unifiedContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    DemandModel: PropTypes.instanceOf(Model).isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendGroupHeader',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DealPublicID,",
            },
            {
              path:
                './ui/app/unified_insights/submodules/demand/submodules/dsp_grid/dsp_grid_model.js',
              lines: [47, 115],
              code:
                "const DspGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...unifiedContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    DemandModel: PropTypes.instanceOf(Model).isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendGroupHeader',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'DeliveredMarketImpression';\n    params.order = 'desc';\n    params.page = 1;\n    params.perPage = 10;\n    params.total = '';\n\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.DSPName,",
            },
          ],
        },
        {
          id: 'cb28f7e7a2ea34a9da15744c2b1da54af59dcdef',
          instances: [
            {
              path: './ui/app/audience_insights/app_model.js',
              lines: [1, 133],
              code:
                "import {\n  createConstants,\n  createModel,\n  ImmutablePropTypes,\n  PropTypes\n} from 'spark-modula';\nimport { OperatingStatsModel } from './submodules/operating_stats';\n\nimport moment from 'moment';\nimport { fromJS } from 'immutable';\n\nimport { UnifiedHeaderLib } from 'app/lib/biz/unified/headers.jsx';\nimport { UnifiedCellLib } from 'app/lib/biz/unified/cells.jsx';\nimport { UnifiedHeaderName } from 'app/lib/biz/unified/labels.jsx';\n\nconst ActionTypes = createConstants('INSIGHT_DASHBOARD', {\n  INIT: null,\n  TAB_TOGGLE: null\n});\n\nconst AppModel = createModel({\n  displayName: 'InsightDashboardModel',\n\n  propTypes: {\n    initted: PropTypes.bool,\n    networkId: PropTypes.string,\n    networkCurrentDate: PropTypes.string,\n    networkStartDate: PropTypes.string,\n    activeTab: PropTypes.oneOf(['operatingStats']),\n    operatingStatsModel: PropTypes.instanceOf(OperatingStatsModel)\n  },\n\n  defaults: {\n    initted: false,\n    networkId: '',\n    networkCurrentDate: '',\n    networkStartDate: '',\n    activeTab: 'operatingStats',\n    operatingStatsModel: null\n  },\n\n  contextTypes: {\n    getNetworkId: PropTypes.func.isRequired,\n    getNetwork: PropTypes.func.isRequired\n  },\n\n  childContextTypes: {\n    networkId: PropTypes.string.isRequired,\n    networkCurrentDate: PropTypes.string.isRequired,\n    networkStartDate: PropTypes.string.isRequired,\n    headerLib: ImmutablePropTypes.map.isRequired,\n    cellLib: ImmutablePropTypes.map.isRequired,\n    headerName: ImmutablePropTypes.map.isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  getChildContext() {\n    return {\n      networkId: this.get('networkId'),\n      networkCurrentDate: this.get('networkCurrentDate'),\n      networkStartDate: this.get('networkStartDate'),\n      headerLib: fromJS(UnifiedHeaderLib),\n      cellLib: fromJS(UnifiedCellLib),\n      headerName: fromJS(UnifiedHeaderName),\n      isInternalColsVisible: this.getContext('getNetwork')().get(\n        'isInternalColsVisible',\n        false\n      )\n    };\n  },\n\n  modelDidMount() {\n    this.sendInit();\n  },\n\n  sendInit() {\n    this.dispatch({\n      type: ActionTypes.INIT\n    });\n  },\n\n  recvInit() {\n    return {\n      type: ActionTypes.INIT,\n      update(model) {\n        const networkId = model.getContext('getNetworkId')();\n        const currentDate = model\n          .getContext('getNetwork')()\n          .get('currentDate');\n        let networkCurrentDate = currentDate || moment().format('YYYY-MM-DD');\n        const networkStartDate = moment(networkCurrentDate)\n          .add(-92, 'days')\n          .format('YYYY-MM-DD');\n\n        const operatingStatsModel = new OperatingStatsModel();\n\n        const newModel = model.setMulti({\n          initted: true,\n          networkId,\n          networkCurrentDate,",
            },
            {
              path: './ui/app/linear_insights/app_model.js',
              lines: [1, 133],
              code:
                "import {\n  createConstants,\n  createModel,\n  ImmutablePropTypes,\n  PropTypes\n} from 'spark-modula';\nimport { OperatingStatsModel } from './submodules/operating_stats';\n\nimport moment from 'moment';\nimport { fromJS } from 'immutable';\n\nimport { UnifiedHeaderLib } from 'app/lib/biz/unified/headers.jsx';\nimport { UnifiedCellLib } from 'app/lib/biz/unified/cells.jsx';\nimport { UnifiedHeaderName } from 'app/lib/biz/unified/labels.jsx';\n\nconst ActionTypes = createConstants('INSIGHT_DASHBOARD', {\n  INIT: null,\n  TAB_TOGGLE: null\n});\n\nconst AppModel = createModel({\n  displayName: 'InsightDashboardModel',\n\n  propTypes: {\n    initted: PropTypes.bool,\n    networkId: PropTypes.string,\n    networkCurrentDate: PropTypes.string,\n    networkStartDate: PropTypes.string,\n    activeTab: PropTypes.oneOf(['operatingStats']),\n    operatingStatsModel: PropTypes.instanceOf(OperatingStatsModel)\n  },\n\n  defaults: {\n    initted: false,\n    networkId: '',\n    networkCurrentDate: '',\n    networkStartDate: '',\n    activeTab: 'operatingStats',\n    operatingStatsModel: null\n  },\n\n  contextTypes: {\n    getNetworkId: PropTypes.func.isRequired,\n    getNetwork: PropTypes.func.isRequired\n  },\n\n  childContextTypes: {\n    networkId: PropTypes.string.isRequired,\n    networkCurrentDate: PropTypes.string.isRequired,\n    networkStartDate: PropTypes.string.isRequired,\n    headerLib: ImmutablePropTypes.map.isRequired,\n    cellLib: ImmutablePropTypes.map.isRequired,\n    headerName: ImmutablePropTypes.map.isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  getChildContext() {\n    return {\n      networkId: this.get('networkId'),\n      networkCurrentDate: this.get('networkCurrentDate'),\n      networkStartDate: this.get('networkStartDate'),\n      headerLib: fromJS(UnifiedHeaderLib),\n      cellLib: fromJS(UnifiedCellLib),\n      headerName: fromJS(UnifiedHeaderName),\n      isInternalColsVisible: this.getContext('getNetwork')().get(\n        'isInternalColsVisible',\n        false\n      )\n    };\n  },\n\n  modelDidMount() {\n    this.sendInit();\n  },\n\n  sendInit() {\n    this.dispatch({\n      type: ActionTypes.INIT\n    });\n  },\n\n  recvInit() {\n    return {\n      type: ActionTypes.INIT,\n      update(model) {\n        const networkId = model.getContext('getNetworkId')();\n        const currentDate = model\n          .getContext('getNetwork')()\n          .get('currentDate');\n        let networkCurrentDate = currentDate || moment().format('YYYY-MM-DD');\n        const networkStartDate = moment(networkCurrentDate)\n          .add(-92, 'days')\n          .format('YYYY-MM-DD');\n\n        const operatingStatsModel = new OperatingStatsModel();\n\n        const newModel = model.setMulti({\n          initted: true,\n          networkId,\n          networkCurrentDate,",
            },
          ],
        },
        {
          id: 'f3c7027ab7d360b65f1e3d968138f0a18021d818',
          instances: [
            {
              path:
                './ui/app/audience_insights/submodules/operating_stats/submodules/daily_grid/daily_grid_model.js',
              lines: [52, 121],
              code:
                "const DailyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Day';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    let startDate = params.startDate;\n    let endDate = params.endDate;\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, startDate, endDate, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data, startDate, endDate } = action.payload;\n\n        const chartData = data.map(record => ({\n          dataKey: record.Day,\n          TrackedRequest: record.TrackedRequest,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/details_grid/details_grid_model.js',
              lines: [51, 120],
              code:
                "const DetailsGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    GridsModel: PropTypes.instanceOf(Model).isRequired\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Day';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    let startDate = params.startDate;\n    let endDate = params.endDate;\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, startDate, endDate, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data, startDate, endDate } = action.payload;\n\n        const chartData = data.map(record => ({\n          dataKey: record.Day,\n          AdInsertion: record.AdInsertion,",
            },
          ],
        },
        {
          id: 'a11d68cf3b629fbf294c932af8b258656b422735',
          instances: [
            {
              path:
                './ui/app/audience_insights/submodules/operating_stats/submodules/hourly_grid/hourly_grid_model.js',
              lines: [41, 117],
              code:
                "  pagination: new Map({ page: 1, perPage: 20 }),\n  searchOptions: [{ key: 'Hour', operator: MATCH }],\n  searchPlaceHolder: 'Search by Hour...',\n  tabName: 'Funnel_Hourly'\n};\n\nconst ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          TrackedRequest: record.TrackedRequest,",
            },
            {
              path:
                './ui/app/linear_insights/submodules/operating_stats/submodules/hourly_grid/hourly_grid_model.js',
              lines: [40, 116],
              code:
                "  pagination: new Map({ page: 1, perPage: 20 }),\n  searchOptions: [{ key: 'Hour', operator: MATCH }],\n  searchPlaceHolder: 'Search by Hour...',\n  tabName: 'Funnel_Hourly'\n};\n\nconst ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader'\n    ]\n  }),\n\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          AdInsertion: record.AdInsertion,",
            },
          ],
        },
        {
          id: '778a75cc9c1711592e651ddb34827381810da146',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/sections_grid/sections_grid_model.js',
              lines: [51, 320],
              code:
                "const SectionGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    competitionFailureChartModel: PropTypes.instanceOf(Model).isRequired,\n    profileCheckChartModel: PropTypes.instanceOf(Model).isRequired,\n    GridsModel: PropTypes.instanceOf(Model).isRequired,\n    sendUpdateGridLinkage: PropTypes.func.isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const competitionFailureChartModel = this.getContext(\n      'competitionFailureChartModel'\n    );\n    const profileCheckChartModel = this.getContext('profileCheckChartModel');\n    competitionFailureChartModel.sendLoading(true);\n    profileCheckChartModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n        const record = data && data[0];\n        const unselectedTotal = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedUnselectedTotal) +\n            (chartShowORTB && record.ORtbUnselectedTotal);\n        const resolvedTotal = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedResolved) +\n            (chartShowORTB && record.ORtbResolved);\n        const competitionFailure = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedCompetitionFailure) +\n            (chartShowORTB && record.ORtbCompetitionFailure);\n        const profileCheck = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedProfileCheckFailed) +",
            },
            {
              path:
                './ui/app/market_insights/submodules/filter_reasons/submodules/videos_grid/videos_grid_model.js',
              lines: [50, 319],
              code:
                "const VideosGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes,\n    competitionFailureChartModel: PropTypes.instanceOf(Model).isRequired,\n    profileCheckChartModel: PropTypes.instanceOf(Model).isRequired,\n    GridsModel: PropTypes.instanceOf(Model).isRequired,\n    sendUpdateGridLinkage: PropTypes.func.isRequired\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const competitionFailureChartModel = this.getContext(\n      'competitionFailureChartModel'\n    );\n    const profileCheckChartModel = this.getContext('profileCheckChartModel');\n    competitionFailureChartModel.sendLoading(true);\n    profileCheckChartModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n        const record = data && data[0];\n        const unselectedTotal = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedUnselectedTotal) +\n            (chartShowORTB && record.ORtbUnselectedTotal);\n        const resolvedTotal = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedResolved) +\n            (chartShowORTB && record.ORtbResolved);\n        const competitionFailure = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedCompetitionFailure) +\n            (chartShowORTB && record.ORtbCompetitionFailure);\n        const profileCheck = isUndefined(record)\n          ? 0\n          : (chartShowTagBased && record.TBasedProfileCheckFailed) +",
            },
          ],
        },
        {
          id: '92427dd690a5115cbac1c1bc545541982980f9a5',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/details_grid/details_grid_model.js',
              lines: [74, 196],
              code:
                "  GridsModel: PropTypes.instanceOf(Model).isRequired\n},\n\nchildContextTypes: {\n  sendUpdatechartDisplay: PropTypes.func.isRequired\n},\n\ngetChildContext() {\n  return {\n    sendUpdatechartDisplay: this.sendUpdatechartDisplay\n  };\n},\n\n...commonGridListMixin({\n  options: {\n    namespace: namespace,\n    initProps\n  },\n  methods: [\n    'modelDidMount',\n    'sendInit',\n    'sendLoad',\n    'sendLoading',\n    'sendLoadingFail',\n    'sendExportToggle',\n    'sendExport',\n    'sendPageChange',\n    'sendPerPageChange',\n    'sendSort',\n    'sendSearch',\n    'sendGroupHeader',\n    'sendUpdatechartDisplay'\n  ]\n}),\n\nsendLoadChart() {\n  const chartsModel = this.getContext('ChartsModel');\n  chartsModel.sendLoading(true);\n  const fetchResource = this.getContext('fetchResource');\n  let params = this.getParams();\n  params.orderBy = 'Day';\n  params.order = 'asc';\n  params.page = 0;\n  params.perPage = 0;\n  params.total = '';\n  let startDate = params.startDate;\n  let endDate = params.endDate;\n  return fetchResource(this.get('resource'), params)\n    .then(({ status, data, total }) => {\n      if (status !== 0) {\n        throw new Error('wrong status!');\n      }\n      this.dispatch({\n        type: ActionTypes.LOADING_CHART,\n        payload: { data, startDate, endDate, total }\n      });\n    })\n    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data, startDate, endDate } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n\n      const chartData = data.map(record => ({\n        dataKey: record.Day,\n        Request:\n          (chartShowTagBased && record.TBasedRequest) +\n          (chartShowORTB && record.ORtbRequest),\n        Response:\n          (chartShowTagBased && record.TBasedResponse) +\n          (chartShowORTB && record.ORtbResponse),\n        Resolved:\n          (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved),\n        PrimaryAdSelected:\n          (chartShowTagBased && record.TBasedNonFallbackMarketAdSelected) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdSelected),\n        PrimaryAdRealSelected:\n          (chartShowTagBased &&\n            record.TBasedNonFallbackMarketAdRealSelected) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdRealSelected),\n        PrimaryAdImpression:\n          (chartShowTagBased && record.TBasedNonFallbackMarketAdImpression) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdImpression)\n      }));\n      const chartsModel = model.getContext('ChartsModel');\n      const barMetrics = fromJS([\n        'Request',\n        'Response',\n        'Resolved',\n        'PrimaryAdRealSelected',\n        'PrimaryAdSelected',\n        'PrimaryAdImpression'",
            },
            {
              path:
                './ui/app/market_insights/submodules/super_market_insights/submodules/daily_grid/daily_grid_model.js',
              lines: [86, 208],
              code:
                "  SuperMarketInsightsModel: PropTypes.instanceOf(Model).isRequired\n},\n\nchildContextTypes: {\n  sendUpdatechartDisplay: PropTypes.func.isRequired\n},\n\ngetChildContext() {\n  return {\n    sendUpdatechartDisplay: this.sendUpdatechartDisplay\n  };\n},\n\n...commonGridListMixin({\n  options: {\n    namespace: namespace,\n    initProps\n  },\n  methods: [\n    'modelDidMount',\n    'sendInit',\n    'sendLoad',\n    'sendLoading',\n    'sendLoadingFail',\n    'sendExportToggle',\n    'sendExport',\n    'sendPageChange',\n    'sendPerPageChange',\n    'sendSort',\n    'sendSearch',\n    'sendGroupHeader',\n    'sendUpdatechartDisplay'\n  ]\n}),\n\nsendLoadChart() {\n  const chartsModel = this.getContext('ChartsModel');\n  chartsModel.sendLoading(true);\n  const fetchResource = this.getContext('fetchResource');\n  let params = this.getParams();\n  params.orderBy = 'Day';\n  params.order = 'asc';\n  params.page = 0;\n  params.perPage = 0;\n  params.total = '';\n  let startDate = params.startDate;\n  let endDate = params.endDate;\n  return fetchResource(this.get('resource'), params)\n    .then(({ status, data, total }) => {\n      if (status !== 0) {\n        throw new Error('wrong status!');\n      }\n      this.dispatch({\n        type: ActionTypes.LOADING_CHART,\n        payload: { data, startDate, endDate, total }\n      });\n    })\n    .catch(() => {\n      this.loadChartFail();\n    });\n},\n\nrecvLoadChart() {\n  return {\n    type: ActionTypes.LOADING_CHART,\n    update(model, action) {\n      const { data, startDate, endDate } = action.payload;\n      const chartShowTagBased = model.get('chartShowTagBased');\n      const chartShowORTB = model.get('chartShowORTB');\n\n      const chartData = data.map(record => ({\n        dataKey: record.Day,\n        Request:\n          (chartShowTagBased && record.TBasedRequest) +\n          (chartShowORTB && record.ORtbRequest),\n        Response:\n          (chartShowTagBased && record.TBasedResponse) +\n          (chartShowORTB && record.ORtbResponse),\n        Resolved:\n          (chartShowTagBased && record.TBasedResolved) +\n          (chartShowORTB && record.ORtbResolved),\n        PrimaryAdSelected:\n          (chartShowTagBased && record.TBasedNonFallbackMarketAdSelected) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdSelected),\n        PrimaryAdRealSelected:\n          (chartShowTagBased &&\n            record.TBasedNonFallbackMarketAdRealSelected) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdRealSelected),\n        PrimaryAdImpression:\n          (chartShowTagBased && record.TBasedNonFallbackMarketAdImpression) +\n          (chartShowORTB && record.ORtbNonFallbackMarketAdImpression)\n      }));\n      const chartsModel = model.getContext('ChartsModel');\n      const barMetrics = fromJS([\n        'Request',\n        'Response',\n        'Resolved',\n        'PrimaryAdRealSelected',\n        'PrimaryAdSelected',\n        'PrimaryAdImpression'",
            },
          ],
        },
        {
          id: '921b8bf04b53a2996e60aaef76e8e38602b0216f',
          instances: [
            {
              path:
                './ui/app/market_insights/submodules/operating_stats/submodules/hourly_grid/hourly_grid_model.js',
              lines: [53, 201],
              code:
                "const ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          Request:\n            (chartShowTagBased && record.TBasedRequest) +\n            (chartShowORTB && record.ORtbRequest),\n          Response:\n            (chartShowTagBased && record.TBasedResponse) +\n            (chartShowORTB && record.ORtbResponse),\n          Resolved:\n            (chartShowTagBased && record.TBasedResolved) +\n            (chartShowORTB && record.ORtbResolved),\n          PrimaryAdSelected:",
            },
            {
              path:
                './ui/app/market_insights/submodules/super_market_insights/submodules/hourly_grid/hourly_grid_model.js',
              lines: [64, 212],
              code:
                "const ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null,\n  UPDATE_CHARTDISPLAY: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes,\n    chartShowORTB: PropTypes.bool,\n    chartShowTagBased: PropTypes.bool\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults,\n    chartShowORTB: false,\n    chartShowTagBased: false\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...marketContextTypes\n  },\n\n  childContextTypes: {\n    sendUpdatechartDisplay: PropTypes.func.isRequired\n  },\n\n  getChildContext() {\n    return {\n      sendUpdatechartDisplay: this.sendUpdatechartDisplay\n    };\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendExportToggle',\n      'sendExport',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendSearch',\n      'sendGroupHeader',\n      'sendUpdatechartDisplay'\n    ]\n  }),\n\n  sendLoadChart() {\n    const chartsModel = this.getContext('ChartsModel');\n    chartsModel.sendLoading(true);\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.total = '';\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartShowTagBased = model.get('chartShowTagBased');\n        const chartShowORTB = model.get('chartShowORTB');\n\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          Request:\n            (chartShowTagBased && record.TBasedRequest) +\n            (chartShowORTB && record.ORtbRequest),\n          Response:\n            (chartShowTagBased && record.TBasedResponse) +\n            (chartShowORTB && record.ORtbResponse),\n          Resolved:\n            (chartShowTagBased && record.TBasedResolved) +\n            (chartShowORTB && record.ORtbResolved),\n          PrimaryAdSelected:",
            },
          ],
        },
        {
          id: 'a3096dc97547e21c959ebc95ded9918558c7c81e',
          instances: [
            {
              path:
                './ui/app/unified_insights/submodules/demand/submodules/hourly_grid/hourly_grid_model.js',
              lines: [34, 147],
              code:
                "  total: 'all',\n  sort: new Map({ order: 'desc', orderBy: 'Hour' }),\n  pagination: new Map({ page: 1, perPage: 20 }),\n  searchOptions: [{ key: 'Hour', operator: MATCH }],\n  searchPlaceHolder: 'Search by Hour...'\n};\n\nconst ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...unifiedContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendGroupHeader',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.searchBy = '';\n    params.searchVal = '';\n    params.total = '';\n\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          OutboundOpportunityInRequest: record.OutboundOpportunityInRequest,\n          ReceivedBid: record.ReceivedBid,\n          ResolvedBid: record.ResolvedBid,\n          SelectedBid: record.SelectedBid,\n          SelectedBidInWatchedSlot: record.SelectedBidInWatchedSlot,\n          DeliveredMarketImpression: record.DeliveredMarketImpression,\n          PlaybackRatio: record.PlaybackRatio * 100,\n          AverageECPM: record.AverageECPM\n        }));\n        const chartsModel = model.getContext('ChartsModel');\n        const barMetrics = fromJS([\n          'OutboundOpportunityInRequest',\n          'ReceivedBid',\n          'ResolvedBid',\n          'SelectedBid',\n          'SelectedBidInWatchedSlot',\n          'DeliveredMarketImpression'\n        ]);\n        const lineMetrics = fromJS(['PlaybackRatio', 'AverageECPM']);\n        return [",
            },
            {
              path:
                './ui/app/unified_insights/submodules/inventory/submodules/hourly_grid/hourly_grid_model.js',
              lines: [42, 155],
              code:
                "  total: 'all',\n  sort: new Map({ order: 'desc', orderBy: 'Hour' }),\n  pagination: new Map({ page: 1, perPage: 20 }),\n  searchOptions: [{ key: 'Hour', operator: MATCH }],\n  searchPlaceHolder: 'Search by Hour...'\n};\n\nconst ActionTypes = createConstants(namespace, {\n  LOADING_CHART: null\n});\n\nconst HourlyGridModel = createModel({\n  propTypes: {\n    ...commonProps.commonPropTypes\n  },\n\n  defaults: {\n    ...commonProps.commonDefaults\n  },\n\n  contextTypes: {\n    ...commonProps.commonContextTypes,\n    ...unifiedContextTypes,\n    ChartsModel: PropTypes.instanceOf(Model).isRequired,\n    isInternalColsVisible: PropTypes.bool\n  },\n\n  ...commonGridListMixin({\n    options: {\n      namespace: namespace,\n      initProps\n    },\n    methods: [\n      'modelDidMount',\n      'sendInit',\n      'sendLoad',\n      'sendLoading',\n      'sendLoadingFail',\n      'sendPageChange',\n      'sendPerPageChange',\n      'sendSort',\n      'sendGroupHeader',\n      'sendSearch',\n      'sendExportToggle',\n      'sendExport'\n    ]\n  }),\n  sendLoadChart() {\n    const fetchResource = this.getContext('fetchResource');\n    let params = this.getParams();\n    params.orderBy = 'Hour';\n    params.order = 'asc';\n    params.page = 0;\n    params.perPage = 0;\n    params.searchBy = '';\n    params.searchVal = '';\n    params.total = '';\n\n    return fetchResource(this.get('resource'), params)\n      .then(({ status, data, total }) => {\n        if (status !== 0) {\n          throw new Error('wrong status!');\n        }\n        this.dispatch({\n          type: ActionTypes.LOADING_CHART,\n          payload: { data, total }\n        });\n      })\n      .catch(() => {\n        this.loadChartFail();\n      });\n  },\n\n  recvLoadChart() {\n    return {\n      type: ActionTypes.LOADING_CHART,\n      update(model, action) {\n        const { data } = action.payload;\n        const chartData = data.map(record => ({\n          dataKey: record.Hour.slice(11, 19),\n          OutboundOpportunityInRequest: record.OutboundOpportunityInRequest,\n          ReceivedBid: record.ReceivedBid,\n          ResolvedBid: record.ResolvedBid,\n          SelectedBid: record.SelectedBid,\n          SelectedBidInWatchedSlot: record.SelectedBidInWatchedSlot,\n          DeliveredMarketImpression: record.DeliveredMarketImpression,\n          PlaybackRatio: record.PlaybackRatio * 100,\n          AverageECPM: record.AverageECPM\n        }));\n        const chartsModel = model.getContext('ChartsModel');\n        const barMetrics = fromJS([\n          'OutboundOpportunityInRequest',\n          'ReceivedBid',\n          'ResolvedBid',\n          'SelectedBid',\n          'SelectedBidInWatchedSlot',\n          'DeliveredMarketImpression'\n        ]);\n        const lineMetrics = fromJS(['PlaybackRatio', 'AverageECPM']);\n        return [",
            },
          ],
        },
      ];
    },
    9: function(e, n, t) {
      e.exports = t(205);
    },
  },
  [[9, 1, 2]],
]);
//# sourceMappingURL=main.0b7ea3f6.chunk.js.map
